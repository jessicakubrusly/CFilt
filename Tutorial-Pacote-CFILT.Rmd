---
title: "PACOTE CFILT"
author: "Thiago Augusto"
date: "26 de maio de 2020"
output:
   rmdformats::readthedown:
    highlight: kate
---

![](simbolo.png)


# Introdução

Este tutorial tem como objetivo detalhar o uso do pacote CFilt de forma a tornar mais claro e prático o uso do pacote para os novos usuários. Esse pacote foi desenvolvido no *software* estatístico R usando programação orientada a objeto, tornando mais amigável a criação de objetos, as manipulações dos bancos de dados e os processos de recomendação.

## Sistemas de Recomendação

A recomendação de itens para consumidores na rede de internet se mostra como uma das ferramentas mais importantes no que tange a utilização de plataformas de venda e entretenimento. Como exemplos, podem ser citados: a recomendação de produtos em sites de vendas, como a *Amazon*; a recomendação de filmes e músicas em serviços *streaming*, como a *Netflix*, *Spotify* e *Youtube*; e recomendações de contatos sociais no *Facebook*, *Instagram* e *Twitter*.

Tal é a importância de se fazer boas recomendações que em 2006 a *Netflix* criou o *Prêmio Netflix*, no qual ofereceu 1 milhão de dólares para quem conseguisse criar um sistema de recomendação que melhorasse as previsões do sistema já utilizado por eles em 10%. Milhares de pessoas de diversas partes do mundo se inscreveram para concorrer ao prêmio e somente em 2009 foi anunciada a equipe vencedora, que era composta por engenheiros da computação e especialistas em estatística e aprendizado de máquinas. 

## Filtragem Colaborativa

Uma das metodologias utilizadas por esses sistemas de recomendação é a Filtragem Colaborativa. A Filtragem Colaborativa baseia-se na chamada Filtragem social, onde as avaliações dos consumidores mais semelhantes ao consumidor-alvo são utilizadas no cálculo da recomendação. Um grupo de consumidores é considerado semelhante se eles avaliam itens em comum de maneira similar, como também, um grupo de itens é considerado semelhante se eles foram avaliados por consumidores em comum com notas similares.


## Instalação do Pacote

Como o pacote já está disponível no CRAN, torna-se mais prática a instalação e a utilização. O único pré-requisito para o uso do pacote é que o R deve estar na versão 3.6.0 ou maior.

```{r message=FALSE, warning=FALSE, cache=TRUE}
install.packages("CFilt")
require(CFilt)
```

>**OBS**: Para a aplicação do pacote, foram utilizados algumas bases de dados reais, além da já incluída no pacote. Para realizar o download desses bancos de dados, clique no link abaixo.

[Banco de Dados Utilizados](https://drive.google.com/drive/folders/1luZDuxUXCL0Lk_i0b48JUU8O9cxUUka_?usp=sharing)

# Classe CF: Estrutura e Objetos 

Para facilitar a manipulação dos dados e agilizar os processos de recomendação, foi criado uma classe chamada **CF**, onde um objeto da classe **CF** é estruturado como um conjunto de outros objetos sendo eles:



- **MU**: uma matriz *M X N* contendo as avaliações dadas pelos *M* usuários para os *N* itens.
- **SU1**: uma matriz triangular superior *M X M* contendo as similaridades entre os *M* usuários. Essa similaridade é calculada através da Distância Cosseno, variando de 0 a 1. 
- **SU2**: uma matriz triangular superior *M X M* contendo as similaridades entre os *M* usuários. Essa similaridade é calculada através da Correlação de Pearson, variando de -1 a 1.
- **SI1**: uma matriz triangular superior *N X N* contendo as similaridades entre os *N* itens. Essa similaridade é calculada através da Distância Cosseno, variando de 0 a 1.
- **SI2**: uma matriz triangular superior *N X N* contendo as similaridades entre os *N* itens. Essa similaridade é calculada através da Distância Cosseno Ajustada, variando de -1 a 1.
- **averages_u**: um vetor contendo as médias das avaliações dos usuários existentes.
- **averages_i**: um vetor contendo as médias das avaliações recebidas de cada item existente.
- **n_aval_u**: um vetor contendo os números de avaliações realizadas por cada usuário.
- **n_aval_i**: um vetor contendo os números de avaliações recebidas de cada item.






Para criar um objeto da classe CF, utilize a função *CFbuilder()*. Essa função só possui um argumento de entrada: `Data`. `Data` pode ser de duas formas: ser propriamente a Matriz de Utilidade ( MU ), com suas linhas e colunas nomeadas corretamente, ou pode ser um *dataframe*, de forma que as três primeiras colunas se configuram respectivamente como ID Usuário, ID Item e Avaliações. Ou seja, cada linha se refere a uma avaliação feita por um usuário para um certo item. 

Para isso, será demonstrado um exemplo para cada um dos casos.


### Caso `Data` for um *dataframe* 



Para testar a função *CFbuilder()* com um *dataframe*, precisa-se de um banco de dados com o formato ideal. O pacote já possui um dataframe chamado *movies* que contém 7276 avaliações de 50 filmes dadas por 526 usuários, com esse formato. Essa base de dados foi criada por Giglio(2014) e as avaliações respeitam a escala de Likert. 


```{r message=FALSE, warning=FALSE, results='hide',cache=T}
head(movies,10)
```


<center>

```{r message=FALSE, warning=FALSE, cache=T, echo=F}
knitr::kable(head(movies,10))
```

</center>


```{r message=FALSE, warning=FALSE, cache=T, echo = T, results = 'hide'}
exemplo<-CFbuilder(movies)
```

```{r message=FALSE, warning=FALSE, cache=T}
class(exemplo)[1]
```

Logo, tem-se que *exemplo* é um objeto de classe CF.


### Caso `Data` for uma Matriz de Utilidade:



Primeiro será criado uma matriz de utilidade exemplo, com avaliações de 100 usuários para 500 filmes. Os identificadores dos usuários variam de 1 a 100 e os identificadores dos itens variam de 1 a 500. As avaliações seguem a escala de Likert.



```{r message=FALSE, warning=FALSE, cache=T}
set.seed(2)
matriz<-matrix(sample(c(NA,1,2,3,4,5),50000,prob=c(0.6,0.08,0.08,0.08,0.08,0.08),replace=T),100,500)
rownames(matriz)<-1:100
colnames(matriz)<-1:500
```

<center>
```{r message=FALSE, warning=FALSE, cache=T, echo=F}
knitr::kable(ifelse(is.na(matriz[1:10,1:10])," ",matriz[1:10,1:10]),row.names = T) #10 primeiras linhas e 10 primeiras colunas da Matriz de Utilidade
```

</center>


```{r message=FALSE, warning=FALSE,cache=T,  echo = T, results = 'hide'}
exemplo2<-CFbuilder(matriz)
```

```{r message=FALSE, warning=FALSE, cache=T}
class(exemplo2)[1]
```

Logo, tem-se que o objeto *exemplo2* é de classe CF.





## Matriz de Utilidade - MU


A Matriz de Utilidade representa o conjunto dos dados a serem analisados e é formada pelas avaliações dos usuários aos itens. A matriz tem dimensão *M × N*, onde cada vetor-linha representa um usuário e cada vetor-coluna representa um item. Ou seja, a i-ésima linha apresenta informações das avaliações realizadas pelo usuário i e a j-ésima coluna apresenta informações das avaliações recebidas pelo item j. Cada entrada $a_{i,j}$ da Matriz de Utilidade é composta pela avaliação do usuário i ao item j, para i ∈ {1, ..., M} e j ∈ {1, ..., N}.



<center>

![Figura 1: Matriz de Utilidade Genérica](Mat_mxn.png)


</center>


Essas avaliações podem seguir diferentes escalas. Tais avaliações podem estar na escala Likert, com notas variando de 1 até 5, ou pela classificação 0 ou 1, indicando se consumidor já adquiriu o item ou não. Normalmente a escala Likert é de 5 pontos, com as notas 5, 4, 3, 2 e 1, que indicam, respectivamente, “Gostei muito”, “Gostei”, “Indiferente”, “Não gostei” e “Detestei”. Mas também há casos em que as avaliações podem ser quebradas, variando de 1 (pior nota) até 5 (melhor nota) com incremento de 0,5. Alguns bancos de dados conhecidos, como o de avaliação de piadas chamado Jester, utilizam a escala com notas variando de -10 a 10. Isso torna as avaliações mais dispersas, tornando viável o não viés das avaliações.

>**OBS**: No caso de base de dados unárias, ou seja, 1 associado a "Assistiu" e NA a "Não Assistiu", não utilize o pacote. Posteriormente será atualizado para esse tipo de base de dados.



Para acessar a MU de um objeto de classe CF, utilize o símbolo *$*.

```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide'}

exemplo$MU[1:10,1:9] # Parte de uma matriz de utilidade 

```
```{r, echo=F}
knitr::kable(ifelse(is.na(exemplo$MU[1:10,1:9])," ",exemplo$MU[1:10,1:9]), row.names = T)

```


> **OBS**: Você pode acessar uma certa nota da MU através dos nomes dos usuários e dos itens.

```{r, message=FALSE, warning=FALSE,  echo = T, cache=T}

exemplo$MU["3","Iron Man 3"] # Nota dada ao item Iron Man 3 pelo usuário "3".

```


## Vetores de Médias: averages_u e averages_i
 
Como forma de informar o utilizador do pacote sobre as avaliações dos usuários, traçando perfis e aplicando diferentes tipos de metodologias da Filtragem Colaborativa, foram criados esses dois vetores. Além disso, tem-se que as colunas estão nomeadas pelos respectivos identificadores.

Para acessar esses dois vetores, utilize o simbolo *$*.

```{r, r, message=FALSE, warning=FALSE, cache=T, echo = T, results = 'hide'}
exemplo$averages_u[1:10] # Selecionando apenas as médias dos 10 primeiros usuários

``` 


<center>

```{r, echo=F}
knitr::kable(exemplo$averages_u[1:10],col.names=c("Médias"), row.names = T)

```


</center>




```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}

exemplo$averages_i[1:10] #Selecionando apenas as médias dos 10 primeiros itens

```



<center>

```{r, echo=F}
knitr::kable(exemplo$averages_i[1:10],col.names=c("Médias"), row.names = T)

``` 

</center> 



Esses vetores podem ser utilizados para verificar o comportamento dos usuários em geral. Para isso basta plotar um histograma.

```{r, message=F, echo=F}
require(ggplot2)
ggplot(data.frame(exemplo$averages_u),aes(x=exemplo.averages_u))+geom_histogram(fill="blue",color="black",breaks=seq(1,5,0.5))+scale_x_continuous(limits = c(1,5), breaks = seq(1,5,1))+scale_y_continuous(limits = c(0,210) ,breaks = seq(0,210,20)) + theme_test() +ylab("Frequência Notas Médias dos Usuários") +xlab("Notas Médias dos Usuários")+ggtitle("Histograma - Perfil dos Usuários")

``` 



O comportamento de um usuário ao avaliar uma lista de filmes se dá através do número de avaliações feitas, do senso crítico individual e dos filmes que foram assistidos. Assim, ao traçar o perfil utilizando as médias de cada usuário, tem-se que a maioria deles avaliaram de forma positiva os filmes vistos. Logo, o banco de dados possui em sua maioria usuários com notas médias entre 3.5 e 4.5. 

Esses comportamentos são mais variados quando há um número maior de filmes disponíveis e avaliados, aumentando o número de avaliações negativas, como também as positivas. Como nesse banco de dados só haviam 50 filmes disponíveis, ter uma nota muito alta ou uma nota muito baixa, influencia no cálculo das médias. 


> **OBS**: Você pode acessar uma ou mais médias através dos nomes dos usuários/itens.

```{r, message=FALSE, warning=FALSE,  echo = T, cache=T}

exemplo$averages_i["Iron Man 3"] # Nota média do item Iron Man 3
exemplo$averages_u["6"] # Nota média do usuário "6"

```

 
## Vetores de Número de Avaliações: n_aval_u e n_aval_i


Na Filtragem Colaborativa tem-se que quanto maior o número de avaliações feitas por cada usuário, melhor é o processo de recomendação. Da mesma forma para um item, onde um item tem maior probabilidade de ser recomendado se for avaliado por mais usuários, contanto que, as avaliações sejam positivas.

Logo, para avaliar o perfil dos usuários quanto a frequência de avaliações, tem-se o vetor *n_aval_u*. Enquanto para avaliar o consumo de certo item, tem-se o vetor *n_aval_i*. Os dois objetos são aplicados na utilização de diversas metodologias da Filtragem Colaborativa.

Esses objetos são acessados através do símbolo *$*.


```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}
exemplo$n_aval_u[1:10] #Selecionando apenas o número de avaliações dos 10 primeiros usuários

``` 


<center>

```{r, echo=F}
knitr::kable(exemplo$n_aval_u[1:10],col.names=c("N° de Avaliações"), row.names = T)

```


</center>

```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}
exemplo$n_aval_i[1:10]   #Selecionando apenas o número de avaliações dos 10 primeiros itens

``` 


<center>

```{r, echo=F}
knitr::kable(exemplo$n_aval_i[1:10],col.names=c("N° de Avaliações"), row.names = T)

```


</center>

Para analisar a frequência você pode plotar um gráfico de barra.

```{r, warning=F, echo=F}

ggplot(data.frame(exemplo$n_aval_u),aes(x=exemplo.n_aval_u)) + geom_bar(stat="count",fill="blue",color="black")+scale_x_continuous(limits = c(0,50), breaks = seq(0,50,5))+scale_y_continuous(limits = c(0,45) ,breaks = seq(0,45,5)) + theme_test() +ylab("Frequência de Avaliações" ) +xlab("N° de Avaliações dos Usuários")+ggtitle("Frequência de Avaliações dos Usuários")


``` 

Nota-se que nesse banco de dados os usuários, em sua maioria, avaliam cerca de 5 a 20 filmes. Enquanto poucos são considerados assíduos.




 




```{r, echo = T, results = 'hide'}
grafico_filmes<-ggplot(data=data.frame(names(exemplo$n_aval_i),exemplo$n_aval_i),aes(x=reorder(names.exemplo.n_aval_i., exemplo.n_aval_i),y=exemplo.n_aval_i))  + geom_bar(stat= "identity",fill="blue",color="black")+ coord_flip() +xlab("Filmes")+ylab("N° de Avaliações")+ ggtitle("Número de Avaliações dos Filmes")+scale_y_continuous(breaks=seq(0,400,50))+geom_text(aes(label=exemplo.n_aval_i ), vjust = 0, hjust = -0.2)+ theme_test()

``` 
![Figura 3: Número de Avaliações dos Filmes](Filmes.png)

Nota-se que o filme menos avaliado possuiu 20 avaliações, enquanto que há muitos filmes avaliados por mais de 100 dos 526 usuários disponíveis. Isso torna o cenário positivo para a recomendação. Pois normalmente filmes mais populares tem tendêcia a serem recomendados.


> **OBS**: Você pode acessar os números de avaliações através dos nomes dos usuários/itens.

```{r, message=FALSE, warning=FALSE,  echo = T, cache=T}

exemplo$n_aval_i["Iron Man 3"] # Número de Avaliações recebidas do item Iron Man 3
exemplo$n_aval_u["6"] # Número de Avaliações do usuário "6"

```


## Matrizes de Similaridade entre Usuários: SU1 e SU2

Usuários são considerados semelhantes se avaliaram de forma similar itens em comum. A semelhança destes usuários é mensurada através de medidas de similaridade. Para análise da proximidade entre usuários é preciso deﬁnir as Matrizes de Similaridade entre Usuários: SU1 e SU2. As Matrizes de Similaridade entre Usuários são matrizes quadradas *M × M*, onde M é o número total de usuários. Cada entrada $S_{i,j}$ das matrizes apresentam as similaridades do usuário i com o usuário j.



<center>

![Figura 2: Matriz de Similaridade entre Usuários](SU.png)


</center>


No cálculo de similaridade entre usuários, considera-se cada usuário um vetor no $\mathbb{R}^{N}$ , formado pelo vetor-linha correspondente da Matriz de Utilidade. Além disso, nota-se que as matrizes de similaridade são simétricas, ou seja, $S_{i,j}^{U}$ = $S_{j,i}^{U}$. Por causa disso, como forma de praticidade computacional, elas foram transformadas em matrizes triangulares superiores.

Há diversas formas de se realizar as recomendações. Para isso, foram criadas duas matrizes de Similaridade, nas quais foram usadas metodologias diferentes. 

### SU1

A SU1 possui similaridades calculadas a partir da Similaridade Cosseno: \[S\left (u,v \right ) = \cos\left ( \alpha \right ) =\frac{x_{u}'x_{v}}{\left \|x_{u} \right \|\left \|x_{v} \right \|}\]
onde $x_{u}$ e $x_{v}$ são os vetores-linhas dos usuários *u* e *v* .

Essa similaridade calcula a proximidade entre dois vetores a partir do cosseno do ângulo formado entre eles. Quanto maior o cosseno, menor o ângulo entre eles e maior a proximidade entre os vetores. O cosseno varia de 0 a 1, ou seja, quanto mais próximo estiver de 1, menor o ângulo entre $x_{u}$ e $x_{v}$, e consequentemente maior é a aproximação de vetores.

Para acessar a matriz utilize o símbolo *$*.

```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}
exemplo$SU1[1:8,1:8]

``` 
```{r, echo=F}
knitr::kable(exemplo$SU1[1:8,1:8], row.names = T)

```



### SU2

A SU2 possui similaridades calculadas a partir da Similaridade de Pearson: \[Pearson(u,v) = \frac{\sum_{k\in _{I_{u}\cap I_{v} }}\left (r_{uk } -\mu_{u} \right )\left (r_{vk }-\mu_{v} \right )}{\sqrt{\sum_{k\in _{I_{u}\cap I_{v} }}\left (r_{uk } -\mu_{u} \right )^{2}}\sqrt{\sum_{k\in _{I_{u}\cap I_{v} }}\left (r_{vk } -\mu_{v} \right )^{2}}}\]

Onde $r_{uk}$ e $r_{vk}$ são equivalentes a $a_{uk }$ e $a_{vk}$, valores da Matriz de Utilidade dadas pelos usuários u/v para o item k em comum. 

Essa similaridade utiliza a média de cada usuário para padronizar as valiações, partindo do pressuposto de que cada usuário tem seu estilo de avaliação, seja mais pessimista ou mais otimista. Sabendo que essa similaridade varia de -1 a 1, quanto mais próximo de 1, mais similares são os usuários. 


Para acessar a matriz utilize o símbolo *$*.

```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}
exemplo$SU2

``` 
```{r, echo=F}
knitr::kable(exemplo$SU2[1:8,1:8], row.names = T)

```

Nota-se que tem-se algumas similaridades são dadas como *NaN* isso acontece quando alguma divisão por 0, que pode acontecer quando há usuários com poucas avaliações. Mas não se preocupe, todo o processo de recomendação já as descarta e os cáculos são feitos normalmente. 

> **OBS**: Você pode acessar uma certa similaridade através dos nomes dos usuários e dos itens. Porém como as matrizes são triangulares superiores, deve ser verificado os dois casos possíveis: $SU1["i","j"] e $SU1["j","i"], pois uma delas está zerada.

```{r, message=FALSE, warning=FALSE,  echo = T, cache=T}

exemplo$SU1["2","3"] # Similaridade entre os Usuários "2" e "3" - Via SU1
exemplo$SU2["2","3"] # Similaridade entre os Usuários "2" e "3" - Via SU2

exemplo$SU1["3","2"]  # Similaridade entre os Usuários "2" e "3" - Via SU1 Parte Zerada
exemplo$SU2["3","2"]  # Similaridade entre os Usuários "2" e "3" - Via SU2 Parte Zerada
```


## Matrizes de Similaridade entre Itens: SI1 e SI2


Itens são considerados semelhantes se receberam avaliações de forma similar por usuários em comum. A semelhança destes itens é mensurada através de medidas de similaridade. Para análise da proximidade entre usuários é preciso deﬁnir as Matrizes de Similaridade entre Itens: SI1 e SI2. As Matrizes de Similaridade entre itens são matrizes quadradas *N × N*, onde N é o número total de itens. Cada entrada $S_{ij}^{I}$ das matrizes apresentam as similaridades do item i com o item j.






<center>

![Figura 3: Matriz de Similaridade entre Itens](SI.png)


</center>


No cálculo de similaridade entre itens, considera-se cada item um vetor no $\mathbb{R}^{N}$ , formado pelo vetor-coluna correspondente da Matriz de Utilidade. Além disso, nota-se que as matrizes de similaridade são simétricas, ou seja, $S_{i,j}^{I}$ = $S_{j,i}^{I}$. Por causa disso, como forma de praticidade computacional, elas foram transformadas em matrizes triangulares superiores.

Há diversas formas de se realizar as recomendações. Para isso, foram criadas duas matrizes de similaridades, nas quais foram usadas metodologias diferentes. 


### SI1

A SI1, analogamente a SU1, também é contruída através do cálculo da similaridade Cosseno. \[S\left (i,j \right ) = \cos\left ( \alpha \right ) =\frac{x_{i}'x_{j}}{\left \|x_{i} \right \|\left \|x_{j} \right \|}\]
onde $x_{i}$ e $x_{j}$ são os vetores-colunas dos itens *i* e *j*.

Para acessar a matriz utilize o símbolo *$*.

```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}
exemplo$SI1

``` 
```{r, echo=F}
knitr::kable(exemplo$SI1[5:11,5:11], row.names = T)

```

### SI2

A SI2 possui similaridades calculadas através da Similaridade Cosseno Ajustada: \[AdjustCos(i,j) = \frac{\sum_{u\in _{U_{i}\cap U_{j} }}s_{ui}\cdot s_{uj}}{\sqrt{\sum_{u\in _{U_{i}\cap U_{j} }}s_{ui}^{2}}\sqrt{\sum_{u\in _{U_{i}\cap U_{j} }}s_{uj}^{2}}}\] sendo

![](suj.png)
 
 e analogamente para $S_{vj}$.

Para acessar a matriz utilize o símbolo *$*.

```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}
exemplo$SI2[5:11,5:11]

``` 
```{r, echo=F}
knitr::kable(exemplo$SI2[5:11,5:11], row.names = T)

```





> **OBS**: Você pode acessar uma certa similaridade através dos nomes dos usuários e dos itens. Porém como as matrizes são triangulares superiores, deve ser verificado os dois casos possíveis: $SI1["i","j"] e $SI1["j","i"], pois uma delas está zerada.

```{r, message=FALSE, warning=FALSE,  echo = T, cache=T}

exemplo$SI1["Argo","Iron Man 3"] # Similaridade entre os itens"Argo" e "Iron Man 3" - Via SI1
exemplo$SI2["Argo","Iron Man 3"] # Similaridade entre os itens"Argo" e "Iron Man 3" - Via SI2

exemplo$SI1["Iron Man 3","Argo"] # Similaridade entre os itens"Argo" e "Iron Man 3" - Via SI1 Zerada
exemplo$SI2["Iron Man 3","Argo"] # Similaridade entre os itens"Argo" e "Iron Man 3" - Via SI2 Zerada

```



# Classe CF: Métodos de Alteração de Objetos

Como forma de agilizar o processo de alteração dos objetos e o processo de recomendação, são disponíveis 11 métodos. Esses métodos são funções ligadas e aplicáveis a apenas objetos de classe CF, gerados a partir da função *CFbuilder()*.


Dentre os 12 métodos criados, esses sete possuem a função de alterar os objetos de classe CF.


- **addnewemptyitem**: adiciona um novo item que não foi avaliado por ninguém.
- **addnewitem**: adiciona um novo item avaliado por 1 ou mais usuários.
- **addnewemptyuser**: adiciona um novo usuário que não avaliou nenhum item.
- **addnewuser**: adiciona um novo usuário que avaliou 1 ou mais itens
- **newrating**: adiciona uma nova avaliação dada por um usuário existente para um item existente.
- **deleterating**: deleta uma avaliação existente.
- **changerating**: altera uma avaliação existente.


Esses métodos são utilizados através do símbolo *$*.

Agora será dicutido sobre o uso de cada um deles de forma detalhada.

## Adicionar novos Usuários: addnewuser e addnewemptyuser

Ao se pensar na utilização de plataformas de streaming e sites de vendas, tem-se que constantemente novos usuários são adicionados a base de dados. Para isso, sabendo que quando novos usuários são adicionados, todos os objetos utilizados para se realizar a recomendação acabam sendo alterados.

Caso queira adicionar um usuário vazio, ou seja, que não avaliou nenhum item, utilize o método *addnewemptyuser* . Ele possui `Id_u` sendo o único argumento de entrada. `Id_u` deve ser um caracter que identifique o novo usuário a ser adicionado. 

E se caso queira adicionar um usuário que tenha avaliado algum item, utilize o método *addnewuser* . Ele possui como argumentos de entrada:

- **Id_u**: um caracter referente ao identificador do novo usuário a ser adicionado. Ex: "1", "Thiago" , "12_3".
- **Ids_i**: um vetor de caracteres referente aos identificadores dos itens já foram avaliados pelo novo usuário.
- **r**: um vetor de avaliações realizadas pelo novo usuário para os itens identificados respectivamente. Ou seja, se o usuário tivesse avaliado 2 itens, r[1] seria a nota referente ao item Ids_i[1] e r[2] seria a nota referente ao item Ids_i[2].



Para demonstrar que houve alterações nos objetos da classe CF, serão comparados o objeto *exemplo* e o objeto *exemplo_user*, o qual será alterado pelos métodos apresentados, em suas respectivas funções.

```{r message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}
#Criar o novo objeto CF
exemplo_user<-CFbuilder(movies)
```

Será adicionado o novo usuário "Thiago" o qual não realizou nenhuma avaliação. Além disso, será adicionado o usuário "Jéssica" que avaliou os filmes *"12 Years a Slave"*,*"Argo"* e *"Amour"*, respectivamente, com as notas 4,3 e 1. 

```{r message=FALSE, warning=FALSE,  echo = T, results = 'hide'}
exemplo_user$addnewemptyuser(Id_u="Thiago")
exemplo_user$addnewuser(Id_u="Jessica",Ids_i=c("12 Years a Slave","Argo","Amour"),r=c(4,3,1))
```

Agora será demonstrado as alterações em todos os objetos estruturados no objeto *exemplo_user*.

### Matriz de Utilidade - MU:


Sem alteração:
```{r,results='hide'}
exemplo$MU[523:nrow(exemplo$MU),1:5] # Últimas linhas e 5 primeiras colunas da Matriz de Utilidade 
```

<center>

```{r, echo=F}
knitr::kable(ifelse(is.na(exemplo$MU[523:nrow(exemplo$MU),1:5])," ",exemplo$MU[523:nrow(exemplo$MU),1:5]), row.names = T)

```


</center>

Nota-se que não há nenhum usuário *"Thiago"* nem *"Jéssica"*.

Com alteração:
```{r, results='hide'}
exemplo_user$MU[523:nrow(exemplo_user$MU),1:5] # Últimas linhas e 5 primeiras colunas da Matriz de Utilidade 
```

<center>

```{r, echo=F}
knitr::kable(ifelse(is.na(exemplo_user$MU[523:nrow(exemplo_user$MU),1:5])," ",exemplo_user$MU[523:nrow(exemplo_user$MU),1:5]), row.names = T)

```


</center>


Agora, nota-se que os usuários foram acrescentados com suas devidas avaliações realizadas.



### Vetores de Médias: averages_u e averages_i.



```{r, results='hide'}

exemplo$averages_u[524:length(exemplo$averages_u)]
exemplo_user$averages_u[524:length(exemplo_user$averages_u)]

```

<center>

```{r, echo=F}
knitr::kable(exemplo$averages_u[524:length(exemplo$averages_u)],col.names=c("Médias"), row.names = T, caption = "Sem alteração:")
knitr::kable(exemplo_user$averages_u[524:length(exemplo_user$averages_u)],col.names=c("Médias"), row.names = T, caption = "Com alteração:")

```


</center>



```{r, results='hide'}

exemplo$averages_i[c("12 Years a Slave","Argo","Amour")]
exemplo_user$averages_i[c("12 Years a Slave","Argo","Amour")]
```


<center>

```{r, echo=F}

knitr::kable(exemplo$averages_i[c("12 Years a Slave","Argo","Amour")],col.names=c("Médias"), row.names = T, caption = "Sem alteração:")
knitr::kable(exemplo_user$averages_i[c("12 Years a Slave","Argo","Amour")],col.names=c("Médias"), row.names = T, caption = "Com alteração:")

```

</center>


Com as novas notas acrescentadas, tem-se a alteração das médias dos filmes *"12 Years a Slave"*,*"Argo"* e *"Amour"*. Enquanto que, ao acrescentarem os novos usuários, o vetor *averages_u* recebe duas novas médias, sendo a do *"Thiago"* 0, pois ele não avaliou nenhum filme e a da *"Jéssica"* 2.6667, pois é dada como a média das três avaliações realizadas.

### Vetores de N°de Avaliações: n_aval_u e n_aval_i:



```{r, results='hide'}
exemplo$n_aval_u[524:length(exemplo$n_aval_u)]
exemplo_user$n_aval_u[524:length(exemplo_user$n_aval_u)]
```

<center>

```{r, echo=F}
knitr::kable(exemplo$n_aval_u[524:length(exemplo$n_aval_u)],col.names=c("N"), row.names = T, caption= "Sem alteração:")

knitr::kable(exemplo_user$n_aval_u[524:length(exemplo_user$n_aval_u)],col.names=c("N"), row.names = T, caption = " Com alteração:")
```


</center>



```{r, results='hide'}
exemplo$n_aval_i[c("12 Years a Slave","Argo","Amour")]
exemplo_user$n_aval_i[c("12 Years a Slave","Argo","Amour")]
```

<center>

```{r, echo=F}

knitr::kable(exemplo$n_aval_i[c("12 Years a Slave","Argo","Amour")],col.names=c("N"), row.names = T, caption= "Sem alteração:")

knitr::kable(exemplo_user$n_aval_i[c("12 Years a Slave","Argo","Amour")],col.names=c("N"), row.names = T, caption = " Com alteração:")
```

</center>




Com as novas notas acrescentadas, tem-se que o vetor *n_aval_u* recebeu mais dois valores, referente aos dois novos usuários adicionados. Sendo 0 para o *"Thiago"* e 3 para a *"Jéssica"*. Além disso, o vetor *n_aval_i* sofreu alterações nos espaços dos filmes *"12 Years a Slave"*,*"Argo"* e *"Amour"*, onde ambos receberam mais uma avalaiação.

### Matrizes de Similaridade entre Usuários: SU1 e SU2.





```{r, results='hide'}

exemplo$SU1[1:4,524:ncol(exemplo$SU1)]
exemplo_user$SU1[1:4,524:ncol(exemplo_user$SU1)]
```

<center>

```{r, echo=F}
knitr::kable(exemplo$SU1[1:4,524:ncol(exemplo$SU1)], row.names = T,caption= "Sem alteração:")
knitr::kable(exemplo_user$SU1[1:4,524:ncol(exemplo_user$SU1)], row.names = T,caption= "Com alteração:")

```

</center>




```{r, results='hide'}

exemplo$SU2[1:4,524:ncol(exemplo$SU2)]
exemplo_user$SU2[1:4,524:ncol(exemplo_user$SU2)]

```

<center>

```{r, echo=F}

knitr::kable(exemplo$SU2[1:4,524:ncol(exemplo$SU2)], row.names = T,caption= "Sem alteração:")
knitr::kable(exemplo_user$SU2[1:4,524:ncol(exemplo_user$SU2)], row.names = T,caption= "Com alteração:")
```

</center>

Nota-se que após adicionar os dois novos usuários, as matrizes de similaridade entre usuários aumentaram suas dimensões e foram acrescentados os seus respectivos valores de similaridade. Como *"Thiago"* avaliou nenhum filme, nota-se que as similaridades dele estão zeradas, porém o mesmo não acontece com as similaridades da Jéssica que já entrou como usuária ativa. 





### Matrizes de Similaridade entre Itens: SI1 e SI2.



```{r,results='hide'}

exemplo$SI1[c("12 Years a Slave","Argo","Amour"),c("12 Years a Slave","Argo","Amour")]
exemplo_user$SI1[c("12 Years a Slave","Argo","Amour"),c("12 Years a Slave","Argo","Amour")]
```

<center>

```{r, echo=F}
knitr::kable(exemplo$SI1[c("12 Years a Slave","Argo","Amour"),c("12 Years a Slave","Argo","Amour")], row.names = T,caption= "Sem alteração:")
knitr::kable(exemplo_user$SI1[c("12 Years a Slave","Argo","Amour"),c("12 Years a Slave","Argo","Amour")], row.names = T,caption= "Com alteração:")

```


</center>






```{r,results='hide'}
exemplo$SI2[c("12 Years a Slave","Argo","Amour"),c("12 Years a Slave","Argo","Amour")]
exemplo_user$SI2[c("12 Years a Slave","Argo","Amour"),c("12 Years a Slave","Argo","Amour")]
```


<center>

```{r, echo=F}

knitr::kable(exemplo$SI2[c("12 Years a Slave","Argo","Amour"),c("12 Years a Slave","Argo","Amour")], row.names = T,caption= "Sem alteração:")
knitr::kable(exemplo_user$SI2[c("12 Years a Slave","Argo","Amour"),c("12 Years a Slave","Argo","Amour")], row.names = T,caption= "Com alteração:")
```


</center>


Ao adicionar novos usuários com avaliações realizadas a certos itens, tem-se que as matrizes de similaridades entre itens também serão alteradas. Essa alteração se dá nas similaridades entre os itens recentemente avaliados, que nesse caso são *"12 Years a Slave"*,*"Argo"* e *"Amour"*. Dentre as alterações é importante destacar que houveram aumentos das similaridades, como por exemplo, entre os filmes *"Argo"* e *"12 Years a Slave"*, mas também houveram decréscimos nas similaridades, como foi no caso entre os filmes *"Amour"* e *"12 Years a Slave"*.





## Adicionar novos Itens: addnewitem e addnewemptyitem


Ao pensar na utilização de plataformas de streaming e sites de vendas, tem-se que constantemente novos itens são adicionados a base de dados. Para isso, sabendo que quando novos itens são adicionados, todas os objetos utilizados para se realizar a recomendação acabam sendo alterados, foram criadas dois métodos.

Caso queira adicionar um item vazio, ou seja, que não foi avaliado por nenhum usuário, utilize o método *addnewemptyitem*. Ele possui `Id_i` sendo o único argumento de entrada. `Id_i` deve ser um caracter que identifique o novo item a ser adicionado. 

Caso queira adicionar um item que tenha sido avaliado por algum usuário, utilize o método *addnewitem* . Ele possui como argumentos de entrada:


- **Id_i**: um caracter referente ao identificador do novo item a ser adicionado. Ex: “1”, “Avengers” , “12_3”.
- **Ids_u**: um vetor de caracteres referente aos identificadores dos usuários que já avaliaram o novo item.
- **r**: um vetor das avaliações do novo item realizadas pelos usuários identificados respectivamente. Ou seja, se o item tivesse sido avaliado por 2 usuários, r[1] seria a nota dada pelo usuário Ids_u[1] e r[2] seria a nota dada pelo usuário Ids_u[2].


Para demonstrar que houveram alterações nos objetos da classe CF, serão compararados o objeto *exemplo* e o objeto *exemplo_item*, o qual será alterado pelos métodos apresentados.

```{r message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}
#Criação do objeto CF
exemplo_item<-CFbuilder(movies)
```

Será adicionado o novo item *"Mulan"* o qual não recebeu nenhuma avaliação. Além disso, será adicionado o item "Star Wars IX" que foi avaliado pelos usuários *"1"*,*"2"*,*"5"* e *"10"*, respectivamente, com as notas 4,3,1 e 5. 


```{r message=FALSE, warning=FALSE,  echo = T, results = 'hide'}
exemplo_item$addnewemptyitem(Id_i="Mulan")
exemplo_item$addnewitem(Id_i="Star Wars IX",Ids_u=c("1","2","5","10"),r=c(4,3,1,5))
```

Agora será discutido as alterações nos objetos estruturados no objeto *exemplo_item*.

### Matriz de Utilidade - MU:


Sem alteração:
```{r, results='hide'}

exemplo$MU[1:5,48:ncol(exemplo$MU)] # Cinco primeiras linhas e últimas colunas
```

<center>

```{r, echo=F}
knitr::kable(ifelse(is.na(exemplo$MU[1:5,48:ncol(exemplo$MU)])," ",exemplo$MU[1:5,48:ncol(exemplo$MU)]), row.names = T)

```


</center>



Nota-se que na Matriz de Utilidade não há nenhum item chamado *"Mulan"* ou *"Star Wars IX"*

Com alteração:
```{r, results='hide'}

exemplo_item$MU[1:5,48:ncol(exemplo_item$MU)] # Cinco primeiras linhas e últimas colunas
```

<center>

```{r, echo=F}
knitr::kable(ifelse(is.na(exemplo_item$MU[1:5,48:ncol(exemplo_item$MU)])," ",exemplo_item$MU[1:5,48:ncol(exemplo_item$MU)]), row.names = T)

```


</center>


Agora, nota-se que os itens foram acrescentados com suas devidas avaliações recebidas.



### Vetores de Médias: averages_u e averages_i.

Ao adicionar novos itens, é notável que algumas médias dos vetores *averages_u* e *averages_i* irão sofrer alterações.



```{r, results='hide'}

exemplo$averages_u[c("1","2","5","10")]
exemplo_item$averages_u[c("1","2","5","10")]
```

<center>

```{r, echo=F}
knitr::kable(exemplo$averages_u[c("1","2","5","10")],col.names=c("Médias"), row.names = T, caption="Sem alteração:")

knitr::kable(exemplo_item$averages_u[c("1","2","5","10")],col.names=c("Médias"), row.names = T, caption="Com alteração:")
```


</center>




```{r, results='hide'}
exemplo$averages_i[48:length(exemplo$averages_i)]
exemplo_item$averages_i[48:length(exemplo_item$averages_i)]
```


<center>

```{r, echo=F}

knitr::kable(exemplo$averages_i[48:length(exemplo_item$averages_i)],col.names=c("Médias"), row.names = T, caption="Sem alteração:")

knitr::kable(exemplo_item$averages_i[48:length(exemplo_item$averages_i)],col.names=c("Médias"), row.names = T, caption="Com alteração:")
```


</center>




Tem-se a alteração nas médias dos usuários *"1"*,*"2"*,*"5"* e *"10"*, e *averages_i* recebeu duas novas médias, a do filme *"Mulan"* e do filme *"Star Wars IX"*. Nota-se também que a nota média do usuário *"1"* não foi alterada. Isso aconteceu pois a média era dada como 4 antes de adicionar uma nota 4 ao novo filme *"Star Wars IX"*. Com isso, a média permaneceu a mesma.

### Vetores de N°de Avaliações: n_aval_u e n_aval_i:


Ao adicionar novos itens já avaliados, os vetores *n_aval_u* e *n_Aval_i* acabam sofrendo alterações.




```{r,results='hide'}

exemplo$n_aval_u[c("1","2","5","10")]
exemplo_item$n_aval_u[c("1","2","5","10")]
```

<center>

```{r, echo=F}
knitr::kable(exemplo$n_aval_u[c("1","2","5","10")],col.names=c("N"), row.names = T, caption="Sem alteração:" )

knitr::kable(exemplo$n_aval_i[48:length(exemplo$n_aval_i)],col.names=c("N"), row.names = T, caption="Com alteração:")
```


</center>




```{r,results='hide'}

exemplo$n_aval_i[48:length(exemplo$n_aval_i)]
exemplo_item$n_aval_i[48:length(exemplo_item$n_aval_i)]
```

<center>

```{r, echo=F}
knitr::kable(exemplo_item$n_aval_u[c("1","2","5","10")],col.names=c("N"), row.names = T, caption="Sem alteração:")

knitr::kable(exemplo_item$n_aval_i[48:length(exemplo_item$n_aval_i)],col.names=c("N"), row.names = T, caption="Com alteração:")
```


</center>


Nota-se que o número de avaliações dos usuários *"1"*,*"2"*,*"5"* e *"10"* aumentou em mais um e o vetor *n_aval_i* recebeu mais dois novos dados, o número de avaliações recebidas do filme *"Mulan"*, sendo 0 e do filme *"Star Wars IX"*, sendo 4.


### Matrizes de Similaridade entre Usuários: SU1 e SU2.

Ao adicionar um novo item já avaliado por alguns usuários, tem-se que as similaridades entre esses usuários acabem sofrendo alterações.



```{r, results='hide'}

exemplo$SU1[c("1","2","5","10"),c("1","2","5","10")]
exemplo_item$SU1[c("1","2","5","10"),c("1","2","5","10")]
```

<center>

```{r, echo=F}
knitr::kable(exemplo$SU1[c("1","2","5","10"),c("1","2","5","10")], row.names = T, caption= "Sem alteração:")

knitr::kable(exemplo_item$SU1[c("1","2","5","10"),c("1","2","5","10")], row.names = T,caption= "Com alteração:")
```


</center>



```{r, results='hide'}

exemplo$SU2[c("1","2","5","10"),c("1","2","5","10")]
exemplo_item$SU2[c("1","2","5","10"),c("1","2","5","10")]
```


<center>

```{r, echo=F}


knitr::kable(exemplo$SU2[c("1","2","5","10"),c("1","2","5","10")], row.names = T, caption= "Sem alteração:")


knitr::kable(exemplo_item$SU2[c("1","2","5","10"),c("1","2","5","10")], row.names = T,caption= "Com alteração:")
```


</center>

Observa-se que algumas similaridades que antes não existiam puderam ser calculadas. Enquanto que a maioria das similaridades foram aumentadas.



### Matrizes de Similaridade entre Itens: SI1 e SI2.


Ao adicionar um novo item, as matrizes de similaridade entre itens aumentam de dimensão e adicionam a elas os valores das similaridades dos novos 2 itens. 


```{r, results='hide'}

exemplo$SI1[1:4,48:ncol(exemplo$SI1)]
exemplo_item$SI1[1:4,48:ncol(exemplo_item$SI1)]


```


<center>

```{r, echo=F}
knitr::kable(exemplo$SI1[1:4,48:ncol(exemplo$SI1)], row.names = T,caption= "Sem alteração:")

knitr::kable(exemplo_item$SI1[1:4,48:ncol(exemplo_item$SI1)], row.names = T,caption= "Com alteração:")
```


</center>


```{r, results='hide'}


exemplo$SI2[1:4,48:ncol(exemplo$SI2)]
exemplo_item$SI2[1:4,48:ncol(exemplo_item$SI2)]

```

<center>

```{r, echo=F}

knitr::kable(exemplo$SI2[1:4,48:ncol(exemplo$SI2)], row.names = T,caption= "Sem alteração:")

knitr::kable(exemplo_item$SI2[1:4,48:ncol(exemplo_item$SI2)], row.names = T,caption= "Com alteração:")
```


</center>

Após visualizar parte das matrizes nota-se que há certas similaridades do filme *"Star Wars IX"* com os filmes *"12 Years a Slave"*, *"A Royal Affair"* e *"American Hustle"*.



## Adicionar, Deletar e Alterar uma nova avaliação: newrating, deleterating e changerating

No meio prático, pode-se avaliar novos filmes, rever um filme, mudar de ideia sobre uma avaliação e avaliar o filme errado por engano. Dada essas situações, foram criados esses 3 métodos. 

Caso você queira adicionar uma nova avaliação, utilize o método *newrating*, o qual possui como argumentos de entrada:

- **Id_u**: um caracter, sendo ele identificador de um usuário já existente que realizará a avaliação.
- **Id_i**: um caracter, sendo ele identificador de um item já existente que receberá a avaliação.
- **r**: a nova avaliação realizada pelo usuário identificado para o item identificado.

Caso você queira deletar uma avaliação, utilize o método *deleterating*, o qual possui como argumentos de entrada:

- **Id_u**: um caracter, sendo ele identificador de um usuário já existente que realizou a avaliação.
- **Id_i**: um caracter, sendo ele identificador de um item já existente que recebeu a avaliação.

E caso você queira alterar uma avaliação, utilize o método *changerating*, o qual possui como argumentos de entrada:

- **Id_u**: um caracter, sendo ele identificador de um usuário já existente que realizou a avaliação.
- **Id_i**: um caracter, sendo ele identificador de um item já existente que recebeu a avaliação.
- **r**: a avaliação que tomará o lugar da avaliação antiga. 


Como tem-se que adicionar, alterar e deletar avaliações acabam alterando os objetos da classe CF,será criado o objeto *exemplo_rating* que será alterado pelos métodos apresentados. Assim poderá ser feitas comparações e demonstrações dessas alterações.

```{r message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}
exemplo_rating<-CFbuilder(movies)
```

Será acrescentado uma nova avaliação 5 do usuário *"1"* ao filme *"12 Years a Slave"*, será deletada a avaliação ao filme *"Brazilian Western"* e será alterado a nota dada para *"Wreck-It Ralph"* para 5.

```{r message=FALSE, warning=FALSE,  echo = T, results = 'hide'}
exemplo_rating$newrating(Id_u="1",Id_i="12 Years a Slave", r=5)
exemplo_rating$deleterating(Id_u="1",Id_i="Brazilian Western")
exemplo_rating$changerating(Id_u="1",Id_i="Wreck-It Ralph", r=5)
```

### Matriz de Utilidade - MU:


Sem alteração:
```{r}
exemplo$MU["1","12 Years a Slave"] 
exemplo$MU["1","Brazilian Western"] 
exemplo$MU["1","Wreck-It Ralph"] 
```

Tem-se que o usuário *"1"* não avaliou o filme *"12 Years a Slave"*. Enquanto que assistiu aos filmes *"Brazilian Western"* e *"Wreck-It Ralph"* avaliando ambos com a nota 4.

Com alteração:
```{r}
exemplo_rating$MU["1","12 Years a Slave"] 
exemplo_rating$MU["1","Brazilian Western"] 
exemplo_rating$MU["1","Wreck-It Ralph"]
```

Após o uso dos métodos, tem-se a nova avaliação do usuário *"1"* para o filme *"12 Years a Slave"* como 5, a nota dada ao *"Brazilian Western"* foi excluída e a nota do filme *"Wreck-It Ralph"* se tornou 5.



### Vetores de Médias: averages_u e averages_i.

**averages_u**:
```{r}

exemplo$averages_u["1"]
exemplo_rating$averages_u["1"]

```


**averages_i**:
```{r}

exemplo$averages_i[c("12 Years a Slave","Brazilian Western","Wreck-It Ralph")]
exemplo_rating$averages_i[c("12 Years a Slave","Brazilian Western","Wreck-It Ralph")]
```

Nota-se que as médias dos três filmes foram alteradas. Além disso, a média geral do usuário *"1"* também aumentou consideravelmente, o que gera grande peso pois dependendo da metodologia utilizada, a média de cada usuário é levada em conta. 


### Vetores de N°de Avaliações: n_aval_u e n_aval_i:

**n_aval_u**:
```{r}
exemplo$n_aval_u["1"]
exemplo_rating$n_aval_u["1"]
```

Tem-se que o usuário *"1"* avaliou somente 3 filmes. E os filmes *"12 Years a Slave"*,*"Brazilian Western"* e *"Wreck-It Ralph"* possuem, respectivamente, 133,165 e 169 avaliações.


**n_aval_i**:
```{r}


exemplo$n_aval_i[c("12 Years a Slave","Brazilian Western","Wreck-It Ralph")]
exemplo_rating$n_aval_i[c("12 Years a Slave","Brazilian Western","Wreck-It Ralph")]
```
Como uma nova avaliação do mesmo usuário foi adicionada e outra deletada, o número de avaliações do usuário *"1"* se mantém. Enquanto isso a quantidade de avaliações dos filmes foram alteradas de acordo com o acontecimento entre elas. *"12 Years a Slave"* recebeu mais 1 avaliação, *"Brazilian Western"* diminuiu uma avaliação e como só houve uma alteração na nota de *"Wreck-It Ralph"*, o número de avaliações do filme se manteve.


### Matrizes de Similaridade entre Usuários: SU1 e SU2.


Quando você acrescenta uma nova avaliação há várias possíveis alterações nas matrizes de similaridades entre usuários.




```{r, results='hide'}

exemplo$SU1[1:3,1:6]
exemplo_rating$SU1[1:3,1:6]

```

<center>

```{r, echo=F}
knitr::kable(exemplo$SU1[1:3,1:6], row.names = T,caption= "Sem alteração:")

knitr::kable(exemplo_rating$SU1[1:3,1:6], row.names = T, caption= "Com alteração:")
```


</center>



```{r,results='hide'}

exemplo$SU2[1:3,1:6]
exemplo_rating$SU2[1:3,1:6]

```


<center>

```{r, echo=F}
knitr::kable(exemplo$SU2[1:3,1:6], row.names = T,caption= "Sem alteração:")

knitr::kable(exemplo_rating$SU2[1:3,1:6], row.names = T, caption= "Com alteração:")
```


</center>



Tem-se que com as alterações, algumas similaridades entre o usuário *"1"* e outros usuários acabaram sofrendo também mudanças.

### Matrizes de Similaridade entre Itens: SI1 e SI2.



```{r,results='hide'}

exemplo$SI1[c("12 Years a Slave","Brazilian Western","Wreck-It Ralph"),c("12 Years a Slave","Brazilian Western","Wreck-It Ralph")]
exemplo_rating$SI1[c("12 Years a Slave","Brazilian Western","Wreck-It Ralph"),c("12 Years a Slave","Brazilian Western","Wreck-It Ralph")]
```


<center>

```{r, echo=F}
knitr::kable(exemplo$SI1[c("12 Years a Slave","Brazilian Western","Wreck-It Ralph"),c("12 Years a Slave","Brazilian Western","Wreck-It Ralph")], row.names = T,caption= "Sem alteração:")

knitr::kable(exemplo_rating$SI1[c("12 Years a Slave","Brazilian Western","Wreck-It Ralph"),c("12 Years a Slave","Brazilian Western","Wreck-It Ralph")],row.names = T,caption= "Com alteração:")
```


</center>




```{r,results='hide'}
exemplo$SI2[c("12 Years a Slave","Brazilian Western","Wreck-It Ralph"),c("12 Years a Slave","Brazilian Western","Wreck-It Ralph")]
exemplo_rating$SI2[c("12 Years a Slave","Brazilian Western","Wreck-It Ralph"),c("12 Years a Slave","Brazilian Western","Wreck-It Ralph")]
```

<center>

```{r, echo=F}
knitr::kable(exemplo$SI2[c("12 Years a Slave","Brazilian Western","Wreck-It Ralph"),c("12 Years a Slave","Brazilian Western","Wreck-It Ralph")],row.names = T,caption= "Sem alteração:")

knitr::kable(exemplo_rating$SI2[c("12 Years a Slave","Brazilian Western","Wreck-It Ralph"),c("12 Years a Slave","Brazilian Western","Wreck-It Ralph")], row.names = T,caption= "Com alteração:")

```


</center>

Sabe-se que não são somente essas mudanças, porém apenas com essas já pode-se ver o quanto altera as matrizes de similaridades e todo o processo de recomendação que as utilizam.




# Classe CF: Métodos de Recomendação


Como o objetivo central desse pacote é a utilização dele para o processo de recomendação, foram criados 5 métodos que realizam recomendações utilizando suas metodologias centrais da Filtragem Colaborativa. Esses métodos são:

- **recommend**: retorna TRUE caso um certo item identificado é recomendável a um certo usuário também identificado, ou retorna FALSE, caso contrário.
- **estimaterating**: esse método, mesmo não sendo diretamente um método de recomendação, pode ser usado para tal, pois retorna a nota estimada de um certo usuário para um certo item. Há diversas escolhas de metodologias para serem realizados os cálculos.
- **topkitems**: retorna os k itens mais recomendáveis a um usuário identificado.
- **topkusers**: retorna os k usuários que possuem maior probabilidade de gostar de um certo item identificado.
- **kclosestitems**: retorna os k itens mais similares a um item identificado.


Todos os 5 métodos possuem 2 argumentos de entrada em comum: `similarity` e `type`. Eles possuem a função principal de designar como vai ser o processo de estimação da nota e consequentemente rotular se um item é recomendável ou não. Para isso, nesse pacote pode-SE realizar uma predição através de 4 maneiras distintas, sendo elas:

- **Se `type` = "user" e `similarity` = "cos".**
- **Se `type` = "user" e `similarity` = "adjcos".**
- **Se `type` = "item" e `similarity` = "cos".**
- **Se `type` = "item" e `similarity` = "adjcos".**

Antes de ser verificado a aplicação dos métodos, serão discitidos essas 4 metodologias diferentes.

### **Se `type` = "user" e `similarity` = "cos"**

Quando `type` = "user", significa que serão usadas as matrizes de similaridade entre usuários para realizar o processo de predição. Porém, nota-se que há duas matrizes de similaridade entre usuários disponíveis: a SU1 e a SU2. Para isso, há o argumento de entrada `similarity`, o qual determina qual matriz utilizar. Nesse caso, `similarity` = "cos" determina o uso da SUI e seu cálculo de predição é realizado através da fórmula:

<center>

![Figura 3: Fórmula do Cálculo da Predição](FORMULA_PREDICAO_PEARSON_1.png)


</center>


### **Se `type` = "user" e `similarity` = "adjcos"**

Como dito anteriormente, quando `type` = "user", significa que serão utilizadas as matrizes de similaridade entre usuários para realizar o processo de predição. Como `similarity` = "adjcos", será utilizada a matriz de similaridade SU2. Essa matriz de similaridade, como já explicada anteriormente, é construída através da aplicação do Coeficiente de Pearson entre os vetores dos usuários levando em conta as médias individuais. Essas médias, além de serem usadas na criação da matriz, serão utilizadas no processo de predição das avaliações, que é dada pela fórmula:


<center>

![Figura 4: Fórmula do Cálculo da Predição](FORMULA_PREDICAO_PEARSON.png)


</center>

### **Se `type` = "item" e `similarity` = "cos"**

Quando `type` = "item", significa que serão usadas as matrizes de similaridade entre itens para realizar o processo de predição. Porém, nota-se que há duas matrizes de similaridade entre itens disponíveis: a SI1 e a SI2. Dado isso, tendo que `similarity` = "cos", será utilizado a matriz de similaridade SI1 e seu cálculo de predição é realizado através da fórmula:

<center>

![Figura 5: Fórmula do Cálculo da Predição](PREDICAO_3.png)


</center>

### **Se `type` = "item" e `similarity` = "adjcos"**

Como dito anteriormente, quando `type` = "item", significa que serão usadas as matrizes de similaridade entre itens para realizar o processo de predição. Como `similarity` = "adjcos", será utilizada a matriz de similaridade SI2. Lembre-se que as similaridades dessa matriz levam em conta a média dos usuários, porém diferentemente do processo de predição utilizando a SU2, essas médias não são utilizadas novamente, tornando o cálculo das predições equivalentes ao caso `similarity` = "cos". Portanto, nesse caso, só modifica-se o uso da matriz, enquanto que o cálculo de predição se mantém o mesmo. 

<center>

![Figura 6: Fórmula do Cálculo da Predição](PREDICAO_2.png)


</center>


Esses métodos são utilizados através do símbolo *$*.

Agora será discutido o uso de cada um deles de forma detalhada.


## Recomendar um item para um usuário: recommend e estimaterating

Para saber se um item é recomendável ou não para um usuário, utiliza-se o método *recommend*. Essa recomendação é feita através do processo de estimação das avaliações. Esse método possui como argumentos de entrada:

- **Id_u**: um caracter identificador do usuário que receberá ou não a recomendação.
- **Id_i**: um caracter identificador do item a ser recomendado.
- **type**: um caracter, podendo ser "user" ou "item". 
- **neighbors**: número de usuários/itens semelhantes utilizados para realizar o cálculo da predição. *default*:5
- **cuts**: nota de corte que determina se um item é recomendável ou não. *default*:3.5.
- **similarity**: um caracter, podendo ser "cos" ou "adjcos", que determina a metodologia utilizada para a predição. *default*:"adjcos".
- **is_binary**: é *TRUE* se o banco de dados é binário e *FALSE*, caso contrário.*default*:FALSE.


Tem-se também o método *estimaterating* que diferentemente do *recommend*, retorna apenas a nota estimada. Muitos cientistas da área avaliam modelos e o uso das predições é essencial para isso.
O método possui os mesmos argumentos de entrada, exceto pela variável `cuts`.

Para demonstrar o uso desses métodos, eles serão para os 4 casos possíveis comentados anteriormente.


#### **Se `type` = "user" e `similarity` = "cos"**
```{r message=FALSE, warning=FALSE,  echo = T}
exemplo$estimaterating(Id_u="2",Id_i="12 Years a Slave",type="user",similarity="cos")
exemplo$recommend(Id_u="2",Id_i="12 Years a Slave",cuts=3.5,type="user",similarity="cos")
```

Como a nota estimada é maior que a nota de corte 3.5, tem-se que *"12 Years a Slave"* é recomendável para o usuário *"2"*. 

#### **Se `type` = "item" e `similarity` = "cos"**
```{r message=FALSE, warning=FALSE,  echo = T}

exemplo$estimaterating(Id_u="2",Id_i="12 Years a Slave",type="item",similarity="cos")
exemplo$recommend(Id_u="2",Id_i="12 Years a Slave",cuts=3.5,type="item",similarity="cos")

```

Como a nota estimada é maior que a nota de corte 3.5, tem-se que *"12 Years a Slave"* é recomendável para o usuário *"2"*. 


#### **Se `type` = "user" e `similarity` = "adjcos"**
```{r message=FALSE, warning=FALSE,  echo = T}

exemplo$estimaterating(Id_u="2",Id_i="12 Years a Slave",type="user",similarity="adjcos")
exemplo$recommend(Id_u="2",Id_i="12 Years a Slave",cuts=3.5,type="user",similarity="adjcos")

```

Como a nota estimada é maior que a nota de corte 3.5, tem-se que *"12 Years a Slave"* é recomendável para o usuário *"2"*. 

#### **Se `type` = "item" e `similarity` = "adjcos"**
```{r message=FALSE, warning=FALSE,  echo = T}
exemplo$estimaterating(Id_u="2",Id_i="12 Years a Slave",type="item",similarity="adjcos")
exemplo$recommend(Id_u="2",Id_i="12 Years a Slave",cuts=3.5,type="item",similarity="adjcos")

```

Como a nota estimada é maior que a nota de corte 3.5, tem-se que *"12 Years a Slave"* é recomendável para o usuário *"2"*. 




## Recomendar k itens para um usuário: topkitems


Em muitos catálogos de sites e serviços de streaming listas são criadas com o objetivo de recomendar itens aos usuários. Com issa ideia, o método *topkitems* foi criado, o qual retorna uma lista de k itens recomendáveis para um certo usuário. Esse método possui como argumentos de entrada:

- **Id_u**: um caracter identificador do usuário que receberá as recomendações.
- **type**: um caracter, podendo ser "user" ou "item". 
- **neighbors**: número de usuários/itens semelhantes utilizados para realizar o cálculo da predição. *default*:5
- **cuts**: nota de corte que determina se um item é recomendável ou não. *default*:3.5.
- **similarity**: um caracter, podendo ser "cos" ou "adjcos", que determina a metodologia utilizada para a predição. *default*:"adjcos".
- **is_binary**: é *TRUE* se o banco de dados é binário e *FALSE*, caso contrário.*default*:FALSE.


Para demonstrar o uso desse método, ele será utilizado para os 4 casos possíveis comentados anteriormente.


#### **Se `type` = "user" e `similarity` = "cos"**


```{r, results='hide',message=FALSE}
filmes <- exemplo$topkitems(Id_u="2", k=3, cuts=3.5, type="user", similarity="cos")
```
```{r,echo=F}
filmes
```

Os filmes recomendados  para o usuário *"2"* foram *"Lincoln"*, *"The Hobbit: The Desolation of Smaug"* e *"Reaching for the Moon"*.

#### **Se `type` = "user" e `similarity` = "adjcos"**

```{r, results='hide',message=FALSE}
filmes <- exemplo$topkitems(Id_u="2", k=3, cuts=3.5, type="user", similarity="adjcos")
```
```{r,echo=F}
filmes
```
Os filmes recomendados  para o usuário *"2"* foram *"Her"*, *"Monsters University"* e *"Reaching for the Moon"*.

#### **Se `type` = "item" e `similarity` = "cos"**
```{r, results='hide',message=FALSE}
filmes <- exemplo$topkitems(Id_u="2", k=3, cuts=3.5, type="item", similarity="cos")
```
```{r,echo=F}
filmes
```
Os filmes recomendados  para o usuário *"2"* foram *"Her"*, *"Amour"* e *"Philomena"*.

#### **Se `type` = "item" e `similarity` = "adjcos"**
```{r, results='hide',message=FALSE}
filmes <- exemplo$topkitems(Id_u="2", k=3, cuts=3.5, type="item", similarity="adjcos")
```
```{r,echo=F}
filmes
```
Os filmes recomendados  para o usuário *"2"* foram *"Her"*, *"The Hobbit: The Desolation of Smaug"* e *"Reaching for the Moon"*.

Nota-se que a escolha da metodologia tem grande influência no resultado da recomendação. Essa diferença acaba sendo maior quando a lista de itens é maior. Cabe o cientista de dados testar e verificar qual a melhor metodologia para o seu banco de dados. 



## Verificar k usuários que gostariam de um item: topkusers

Com o avanço do uso de divulgação de propagandas, seja através de anúncios ou trailers, tem-se a ideia de se obter uma lista de usuários que gostariam de um item específico. Com esse intuito, foi criado o método *topkusers* que retorna essa lista para um certo item. Esse método, seguindo a linha dos outros métodos, possui como argumento de entrada:

- **Id_i**: um caracter identificador que se refere ao item que os usuários recomendados devem gostar.
- **type**: um caracter, podendo ser "user" ou "item". 
- **neighbors**: número de usuários/itens semelhantes utilizados para realizar o cálculo da predição. *default*:5
- **cuts**: nota de corte que determina se é recomendável ou não. *default*:3.5.
- **similarity**: um caracter, podendo ser "cos" ou "adjcos", que determina a metodologia utilizada para a predição. *default*:"adjcos".
- **is_binary**: é *TRUE* se o banco de dados é binário e *FALSE*, caso contrário.*default*:FALSE.


Para demonstrar o uso desse método, ele será utilizado para os 4 casos possíveis comentados anteriormente.


#### **Se `type` = "user" e `similarity` = "cos"**
```{r, results='hide',message=FALSE}
usuarios <- exemplo$topkusers(Id_i="Iron Man 3", k=3, cuts=3.5, type="user", similarity="cos")
```
```{r,echo=F}
usuarios
```

Os usuários *"388"*,*"251"* e *"102"* irão gostar do filme *"Iron Man 3"*.

#### **Se `type` = "user" e `similarity` = "adjcos"**
```{r, results='hide',message=FALSE}
usuarios <- exemplo$topkusers(Id_i="Iron Man 3", k=3, cuts=3.5, type="user", similarity="adjcos")
```
```{r,echo=F}
usuarios
```

Os usuários *"12"*,*"183"* e *"394"* irão gostar do filme *"Iron Man 3"*.


#### **Se `type` = "item" e `similarity` = "cos"**
```{r, results='hide',message=FALSE}
usuarios <- exemplo$topkusers(Id_i="Iron Man 3", k=3, cuts=3.5, type="item", similarity="cos")
```
```{r,echo=F}
usuarios
```

Os usuários *"26"*,*"396"* e *"9"* irão gostar do filme *"Iron Man 3"*.


#### **Se `type` = "item" e `similarity` = "adjcos"**
```{r, results='hide',message=FALSE}
usuarios <- exemplo$topkusers(Id_i="Iron Man 3", k=3, cuts=3.5, type="item", similarity="adjcos")
```
```{r,echo=F}
usuarios
```

Os usuários *"9"*,*"439"* e *"12"* irão gostar do filme *"Iron Man 3"*.

Nota-se que há diferença entre os as escolhas e essa diferença pode crescer quando a lista é maior. Cabe ao cientista saber qual a escolha mais adequada a sua base de dados. 



## Verificar os k itens mais similares a um item: kclosestitems


Quando uma pessoa não cadastrada acessa um site de vendas online em busca de algo, itens são recomendados. Como o processo de recomendação normalmente é realizado através do histórico de avaliações do usuário, essa recomendação é feita de forma alternativa.

Essa alternativa é verificar os itens mais similares a um item que esse usuário está pesquisando. Através dessa situação, fora criado o método *kclosestitems*. Esse método possui como argumentos de entrada apenas:

- **Id_i**: um caracter identificador do item, o qual será verificado os mais semelhantes a ele.
- **k**: número de itens mais semelhantes a um item identificado. *default*=5
- **similarity**:  um caracter, podendo ser "cos" ou "adjcos", que determina a escolha das matrizes de similaridades. *default*:"adjcos".
- **is_binary**: é *TRUE* se o banco de dados é binário e *FALSE*, caso contrário.*default*:FALSE.


> **OBS**: Como é verificado a semelhança entre itens, há a utilização apenas da matriz SI1 ou da matriz SI2. Ou seja, não há o uso da variável `type`. Além disso, nesse caso não há uma predição realizada, apenas utiliza-se as similaridades presentes na matriz escolhida.


Dessa forma, será demonstrado o uso do método para as duas situações possíveis.

#### **Utilizando a *SI1* :**
```{r message=FALSE, warning=FALSE,  echo = T}

exemplo$kclosestitems(Id_i="12 Years a Slave", k = 5, similarity="cos")
```

#### **Utilizando a *SI2* :**
```{r message=FALSE, warning=FALSE,  echo = T}
exemplo$kclosestitems(Id_i="12 Years a Slave", k = 5, similarity="adjcos")

```

Tem-se que dos cinco filmes listados, há apenas dois filmes em comum: *"Les Miserables"* e *"Life of Pi"*.

# Aplicações em Outros Tipos de Dados

## Bases de Dados Binárias

Diferentemente das bases de dados unárias, que é utilizada pela *Amazon*, os quais tem-se a ideia: "Clientes que compraram esse produto também compraram tais produtos", bases binárias são encontradas facilmente, quando tem-se o uso de 0 e 1, onde 0 representa "Não Gostei" enquanto 1 representa "Gostei".


Para isso, será mostrado a utilização desse pacote para esse tipo de dados e comentado as mudanças de interpretações. De forma prática será realizada uma trasformação do banco de dados *movies* que está na escala de Likert para a escala binária. Para a tranformação, foram associadas as notas maiores que 3 a "Gostei" e menores e iguais a 3 a "Não Gostei". Essa decisão é totalmente subjetiva, cabendo ao cinetista de dados tomá-la para melhorar seu sistema de recomendação.

```{r message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}

#Transformação de Avaliações
movies_bin=ifelse(as.numeric(as.character(movies[,3]))>3,1,0)
movies_bin = data.frame(movies[,1:2],movies_bin)

#Construção do Objeto CF:
exemplo_bin<-CFbuilder(movies_bin)

```


#### Matriz de Utilidade

```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}

exemplo_bin$MU[1:10,1:9] # Parte de uma matriz de utilidade 

```
```{r, echo=F}
knitr::kable(ifelse(is.na(exemplo_bin$MU[1:10,1:9])," ",exemplo_bin$MU[1:10,1:9]), row.names = T)

```


#### Vetores de Frequências

Nesse caso, nota-se que os vetores *averages_u* e *averages_i* representarão, respectivamente, a frequência dos usuários gostarem de um item e a frequência dos itens serem avaliados positivamente.



```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}

exemplo_bin$averages_u[10:15] 

```

<center>

```{r, echo=F}
knitr::kable(exemplo_bin$averages_u[10:15],digits = 4,col.names = "Frequência Positiva", row.names = T, longtable = TRUE)

```

</center>

Nota-se que os usuários *"12"* e *"13"* gostaram de todos os filmes que eles assistiram presentes na lista, enquanto há o usuário *"11"* que só gostou de 40%.

```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}

exemplo_bin$averages_i[10:15] 

```



<center>

```{r, echo=F}

knitr::kable(exemplo_bin$averages_i[10:15],digits = 4,col.names = "Frequência Positiva", row.names = T, longtable = TRUE)
```

</center>

Nota-se que dos que assitiram *"Dallas Buyers Club"*, *"Despicable Me 2"* e *"Django Unchained"*, cerca de 90% ou mais gostaram dos filmes. 


#### Alteração de Objetos



Para adicionar um novo usuário, um novo item ou uma nova avaliação, o processo é o mesmo, porém deve-se tomar precauções. Se sua base é binária, o argumento de entrada `r` deve ser um vetor de 0 e/ou 1.

```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}

exemplo_bin$addnewuser(Id_u="Thiago",Ids_i=c("Argo","Iron Man 3", "Amour","Her"),r=c(1,0,0,1)) 

```

Assim, tem-se um novo usuário na base de dados que assistiu aos filmes *"Argo"*,*"Iron Man 3"*, *"Amour"* e *"Her"*, sendo que gostou apenas dos filmes *"Argo"* e *"Her"*.



#### Recomendações



Ao se pensar no processo de recomendação, torna-se importante saber quando um item é recomendável ou não. Se a escala é binária, ou seja, 0 para "Não Gostou" e 1 para "Gostou", quanto mais próximo do 1, maior a probabilidade de ter gostado do item. Então, através dessa ideia, serão utilizados os métodos de recomendação da mesma forma, porém com uma atenção maior para o argumento de entrada `cuts`. Como já descrito, o `cuts` determina a nota de corte. Então, dada a escala, será escolhido `cuts = 0.7`. Porém, cabe ao cientista de dados designar essa nota de corte de forma a tornar adequado para a base de dados.


Outro detalhe é em relação ao argumento de entrada `is_binary`, no qual, para uso de banco de dados binários, deve-se ser atribuído o valor *TRUE*. Essa variável atribuirá a metodologia *default* adequada do argumento de entrada `similarity`, pois metodologias que utilizam os vetores de médias/frequências não são aconselháveis. 



```{r, results = 'hide',message=FALSE}

filmes_bin <- exemplo_bin$topkitems(Id_u="20",k=5,type="user",cuts=0.7, is_binary = TRUE)


```

```{r,echo=F}
filmes_bin
```

Logo, tem-se que o usuário *"20"* irá gostar dos filmes *"Argo"*, *"Beasts of the Southern Wild"*, *"Blue Is The Warmest Color"*,  *"Django Unchained"* e *"Fast & Furious 6"*. Nesse caso foi utilizado a recomendação através das semelhanças entre usuários, calculada através da fórmula de Pearson.
Porém, caso você queira realizar com as outras escolhas, é só alterar o argumento de entrada `type`.


```{r, results = 'hide',message=FALSE}

user_bin <- exemplo_bin$topkusers(Id_i="Life of Pi",k=5,type="user",cuts=0.7,is_binary = TRUE)


```

```{r,echo=F}
user_bin
```

Logo, tem-se os usuários *"5"*,*"12"*, *"36"*,*"38"* e *"41"* que irão gostar do filme *"Life of Pi"*. Nesse caso foi utilizado a recomendação através das semelhanças entre usuários, calculada através da fórmula de Pearson. Porém, caso você queira realizar com as outras escolhas, é só alterar os argumentos de entrada `type` e `similarity`.





## Base de Dados Jester: -10 a 10.

Uma base de dados muito famosa é a Jester, que contém avaliações de piadas na escala de -10 a 10. Essa base de dados foi criada por Ken Goldberg da UC Berkeley. Dado isso, será demonstrado o uso do pacote com esse banco de dados, que contém 24.983 usuários e 100 piadas. 

O processo de construção do objeto CF acaba sendo muito demorado graças a quantidade de informações recebidas e toda a complexidade dos objetos criados.

O banco de dados disponível não vem da forma perfeita para ser utilizado no pacote, para isso precisa-se seguir certos passos:

- **Passo 1**: Transformar os "99" em NAs.
- **Passo 2**: Retirar a 1ª coluna.
- **Passo 3**: Transformar numa matriz
- **Passo 4**: Adicionar os identificadores dos usuários

Assim, já pode ser inserido na função **CFbuilder()**

Como o banco de dados é muito grande, foram selecionadas as avaliações de somente 5.000 dos 24.983 usuários disponíveis. Caso você tenha um computador mais pontente, poderá utilizar para o banco de dados completo.


> **OBS**: Caso utilize o banco de dados completo, os resultados serão diferentes dos que serão apresentados a seguir. 


```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T }
library(readxl)
# O passo 1 já foi realizado no Excel, ou seja, o banco de dados disponível já possui a troca de 99 por NA.
piadas <- read_excel("jester-data-1.xls")
piadas = piadas [,-1] # Passo 2
piadas = as.matrix(piadas) # Passo 3
rownames(piadas)<-1:24983 # Passo 4 
exemplo_piadas<-CFbuilder(piadas[1:5000,])

```


#### Matriz de Utilidade

Diferente da maioria dos banco de dados utilizados na Filtragem Colaborativa, a matriz de utilidade do banco de dados Jester é pouco esparça, ou seja, há muito mais avaliações realizadas. O que ajuda no processo de recomendação.

Nota-se pelo exemplo:


```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T }
exemplo_piadas$MU[1:12,1:12]

```

<center>

```{r, echo=F}
knitr::kable(ifelse(is.na(exemplo_piadas$MU[1:12,1:12])," ",exemplo_piadas$MU[1:12,1:12]),row.names = T)

```


</center>


#### Vetores de Médias

 Com a escala totalmente diferente e o número reduzido de piadas, tem-se que as médias dos usuários e dos itens são bem diferentes entre si. 
 

```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T }
exemplo_piadas$averages_u[1:6]
```

<center>

```{r, echo=F}
knitr::kable(exemplo_piadas$averages_u[1:6],row.names = T,col.names = "Médias")
```
 
</center>
 
```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T }
exemplo_piadas$averages_i[1:6]
```

<center>

```{r, echo=F}
knitr::kable(exemplo_piadas$averages_i[1:6],row.names = T, col.names = "Médias")
```
 
</center>




Caso você queira, pode-se verificar os perfis dos comportamentos dos usuários através de um histograma.

```{r, message=F, echo=F}
require(ggplot2)
ggplot(data.frame(exemplo_piadas$averages_u),aes(x=exemplo_piadas.averages_u))+geom_histogram(fill="green",color="black",breaks=seq(-10,10,0.5))+scale_x_continuous(limits = c(-10,10), breaks = seq(-10,10,2))+scale_y_continuous(limits = c(0,700) ,breaks = seq(0,700,100)) + theme_test() +ylab("Frequência Notas Médias dos Usuários") +xlab("Notas Médias dos Usuários")+ggtitle("Histograma - Perfil dos Usuários")

``` 

Nota-se que a maioria dos usuários possuem notas médias entre 0.5 a 3.5. Isso pode ser graças a um número consideravel de piadas consideradas ruins ou graças ao senso crítico e de humor de cada usuário.

#### Alteração de Objetos

Para acrescentar uma nova piada que já foi avaliada por alguns usuários, utilize a função *addnewitem*, lembrando que ao determinar o `r`, podem se usar valores pertencentes a escala -10 a 10.

```{r,message=F,results='hide'}
exemplo_piadas$addnewitem(Id_i = "j101", Ids_u = c("1","2","3","4","5","6","7","8"), r=c(-3.45,4,2,9.85,-8.43,6.66,4.65,-5.1))

```

Lembre-se sempre que se os dados estiverem numa escala diferente, deve-se acrescentar notas através da variável `r` de forma condizente com o banco de dados.


#### Recomendações

Para realizar os processos de recomendação, utilize o método *topkitems()*, porém utilize o argumento de entrada `cuts` para determinar a nota de corte determinante para saber se uma piada é considerada recomendável ou não. Nesse caso, irá ser utilizado `cuts=2`.

```{r, results = 'hide',message=FALSE}
jokers <- exemplo_piadas$topkitems("3",k=5,type="user", cuts=2)

```
```{r,echo=F}
jokers
```

Através disso, tem-se piadas *"j17"*,*"j93"*,*"j87"*,*"j55"* e *"j2"*  para serem recomendadas ao usuário *"3"*.


Para verificar quais usuários irão gostar de uma certa piada, utilize o método *topkusers()*, se atentando a variável `cuts`.

```{r, results = 'hide',message=FALSE}
jokers<-exemplo_piadas$topkusers("j12",k=8,type="user", cuts=2)

```
```{r,echo=F}
jokers
```

Logo tem-se que os usuários *"2448"*, *"3736"*, *"4376"*, *"1093"*, *"1378"*, *"2072"*, *"2291"* e *"1178"* irão gostar da piada *"j12"*.

## Base de Dados MovieLens: 0.5 a 5.

O grupo *GroupLens* resolveu coletar avaliações de filmes por usuários presentes no site *MovieLens* de forma que esses dados possam ser utilizados para pesquisas de sistemas de recomendação. Dado isso, serão demonstrados o uso de alguns métodos do pacote com essa base de dados. O *GroupLens* disponibiliza bancos de dados de diversos tamanhos, sejam os mais atuais até os mais antigos. Dado isso, será utilizado o banco de dados contendo 100.836 avaliações de  9.724 filmes por 610 usuários. As avaliações variam de 0.5 a 5, com incremento de 0.5.

O processo de construção do objeto CF acaba sendo muito demorado graças a quantidade de informações recebidas e toda a complexidade dos objetos criados.



```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T, cache.lazy = FALSE}
library(readr)
movielens <- read_delim("base_MU_2.csv",";", escape_double = FALSE, trim_ws = TRUE)

exemplo_movies<-CFbuilder(movielens)
```



#### Matriz de Utilidade:

Como são no total 100.836 avaliações de 9.724 filmes dadas por 610 usuários, há apenas 1,7% das avaliações preenchidas. 
```{r, results='hide'}

exemplo_movies$MU[1:10,1:10]

```

<center>
```{r, echo=F}

knitr::kable(ifelse(is.na(exemplo_movies$MU[1:10,1:10])," ",exemplo_movies$MU[1:10,1:10]),row.names=T)

```

</center>


#### Vetores de Médias

Com a escala um pouco maior do que a de Likert e um número vasto de usuários e itens, tem-se que as médias dos usuários e dos itens são bem diferentes entre si.

```{r, results='hide'}

exemplo_movies$averages_u[1:4]

```

<center>
```{r, echo=F}

knitr::kable(exemplo_movies$averages_u[1:4],row.names=T, col.names="Médias")

```

</center>


```{r, results='hide'}

exemplo_movies$averages_i[1:4]

```

<center>
```{r, echo=F}

knitr::kable(exemplo_movies$averages_i[1:4],row.names=T,col.names = "Médias")

```

</center>


#### Alteração de objetos:

Para adicionar um novo usuário, utilize o método *addnewuser*, como já explicado anteriormente. Porém atente-se, o argumento de entrada `r` deve ser um vetor contendo notas que pertencem a escala utilizada no banco de dados.

```{r, message=FALSE, warning=FALSE,  echo = T, results = 'hide', cache=T}

exemplo_movies$addnewuser(Id_u="Jéssica",Ids_i=c("1","1046","101"),r=c(0.5,2,4.5)) 

```
Dessa forma, foi adicionado um novo usuário *"Jéssica"* que avaliou os filmes *"1"*,*"1046"* e *"101"*, respectivamente com as notas 0.5,2 e 4.5



#### Recomendações:

Para receber uma lista de recomendações para um certo usuário, utilize o método *topkitems()*, porém utilize o argumento de entrada `cuts` para determinar a nota de corte determinante para saber se uma piada é considerada recomendável ou não. Como o *default* é dado como 3.5, não será preciso alterar, somente se caso você queira.

```{r, results = 'hide',message=FALSE}
movie <- exemplo_movies$topkitems("1",k=3,type="user")

```
```{r,echo=F}
movie
```

Através disso, tem-se os filmes *"40491"*,*"5181"* e *"5746"* para serem recomendados ao usuário *"1"*.


Para verificar quais usuários irão gostar de uma certo filme, utilize o método *topkusers()*.

```{r, results = 'hide',message=FALSE}
movie<-exemplo_movies$topkusers("1",k=3,type="user")

```
```{r,echo=F}
movie
```

Logo tem-se que os usuários *"251"* , *"12"* e *"538"* irão gostar do filme *"1"*.






# Referências


- Aggarwal, C. C. (2016). Recommender systems (Vol. 1). Cham: Springer International Publishing.

- Eigentaste: A Constant Time Collaborative Filtering Algorithm. Ken Goldberg, Theresa Roeder, Dhruv Gupta, and Chris Perkins. Information Retrieval, 4(2), 133-151. July 2001.

- F. Maxwell Harper and Joseph A. Konstan. 2015. The MovieLens Datasets: History and Context. ACM Transactions on Interactive Intelligent Systems (TiiS) 5, 4: 19:1–19:19.

- Leskovec, J., Rajaraman, A., & Ullman, J. D. (2020). Mining of massive data sets. Cambridge university press.

- LINDEN, G.; SMITH, B.; YORK, J. Amazon. com recommendations: Item-toitem collaborative filtering. Internet Computing, IEEE, v. 7, n. 1, p. 76-80,2003

- Giglio , J. C. (2014). Recomendação de Filmes Utilizando Filtragem Colaborativa [Recommending Films Using Collaborative Filtering]. Undergraduate thesis - Universidade Federal Fluminense.



[Voltar para a página inicial](http://cienciadedados.uff.br/)
